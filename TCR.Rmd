---
title: "Clones R Us: Deep dive into immunarch for immune repertoire profiling"
author: "Kevin Y. Rono"
output:
  word_document: default
  pdf_document: default
  html_document: default
---

**Loading Immunarch**
```{r}
# library(immunarch)

library(devtools)
library(forcats)

# load package w/o installing
load_all('/immunarch) # replace with path to `immunarch` folder
```


**Data Loading**
```{r}
# Memory Size
# Windows-specific
memory.limit(8000000)
memory.size()

# Data Loading
path <- "/directory"

# path argument is a path to the folder with your file or files including metadata file also (if you have one).
TCR_immdata <- repLoad(path)

names(TCR_immdata)

# The function returns the most abundant clonotypes for the given repertoire:
abundant <- top(TCR_immdata$data[[1]])

# returns a list of data frames with coding sequences
coding_sequences <- coding(TCR_immdata$data[[1]])

# computation of the number of filtered sequences
filtered_sequences <- nrow(inframes(TCR_immdata$data[[1]]))

# out-of-frame clonotypes
out_of_frame_clonotypes <- nrow(outofframes(TCR_immdata$data[[1]]))

# Get subset of clonotypes with a specific V gene
# i noticed that the v_name is converted from 'IGHV03-11' to 'IGHV3-11'
specific_v_gene <- filter(TCR_immdata$data[[1]], V.name == 'IGHV3-11')
```


**Basic Analysis and Clonality**
```{r}
# Basic Analysis

# Compute basic statistics, such as number of clones or distributions of lengths and counts. To explore them you need to pass the statistics, e.g. count, to the .method.
exp_vol <- repExplore(TCR_immdata$data, .method = "volume")
(p1 <- vis(exp_vol, .sort = T, .x_axis_adjust = T))

(p2 <- vis(exp_vol, .by = c("pCRstatus"), .meta = TCR_immdata$meta))

# Plots generated by the vis function as well as any ggplot2-based plots can be passed to fixVis—built-in software tool for making publication-ready plots:
exp_len <- repExplore(TCR_immdata$data, .method = "len", .col = "aa")
# (p3 <- vis(exp_len)) # doesn't plot anything

# Fix and make publication-ready results
# fixVis(p2)

exp_cnt <- repExplore(TCR_immdata$data, .method = "count")
# (p4 <- vis(exp_cnt)) # doesn't plot anything

# You can group samples by their metainformation
(p5 <- vis(exp_len, .by = "pCRstatus", .meta = TCR_immdata$meta))
# (p6 <- vis(exp_cnt, .by = "pCRstatus", .meta = TCR_immdata$meta)) # doesn't plot anything


# Clonality

# repClonality Measures the amount of the most or the least frequent clonotypes

# clonal.prop method computes the proportion of repertoire occupied by the pools of cell clones
(imm_pr <- repClonality(TCR_immdata$data, .method = "clonal.prop"))

# The top method considers the most abundant cell clonotypes:
(imm_top <- repClonality(TCR_immdata$data, .method = "top", .head = c(10, 100, 1000, 3000, 10000)))

# The rare method deals with the least prolific clonotypes
(imm_rare <- repClonality(TCR_immdata$data, .method = "rare"))

# The homeo method assesses the clonal space homeostasis, i.e., the proportion of the repertoire occupied by the clones of a given size
(imm_hom <- repClonality(TCR_immdata$data,
                         .method = "homeo",
                         .clone.types = c(Small = .0001, Medium = .001, Large = .01, Hyperexpanded = 1)
))

vis(imm_top, .sort = F, .x_axis_adjust = T, .x_axis_reorder = T)

vis(imm_top, .by = "pCRstatus", .meta = TCR_immdata$meta)

vis(imm_hom, .sort = F, .x_axis_adjust = T, .x_axis_reorder = T)

vis(imm_hom, .by = c("pCRstatus"), .meta = TCR_immdata$meta)

vis(imm_rare, .sort = F, .x_axis_adjust = T, .x_axis_reorder = T)

vis(imm_rare, .by = "pCRstatus", .meta = TCR_immdata$meta)
```

```{r}
# Repertoire Overlap

imm_ov1 <- repOverlap(TCR_immdata$data, .method = "public", .verbose = F)
imm_ov2 <- repOverlap(TCR_immdata$data, .method = "morisita", .verbose = F)

(p1 <- vis(imm_ov1))
(p2 <- vis(imm_ov2, .text.size = 2))

vis(imm_ov1, "heatmap2")

# To analyse the computed overlap measures function apply repOverlapAnalysis
# Apply different analysis algorithms to the matrix of public clonotypes:
# "mds" - Multi-dimensional Scaling
repOverlapAnalysis(imm_ov1, "mds")

# "tsne" - t-Stochastic Neighbor Embedding
repOverlapAnalysis(imm_ov1, "tsne")

# Visualise the results
repOverlapAnalysis(imm_ov1, "mds") %>% vis()

# Clusterise the MDS resulting components using K-means
repOverlapAnalysis(imm_ov1, "mds+kmeans") %>% vis()
```


**Gene Usage Computation**
```{r}
# Gene Usage Computation
gene_stats()

# Next four function calls are equal. "hs" is from the "alias" column.
imm_gu <- geneUsage(TCR_immdata$data, "hs.trbv")
# imm_gu = geneUsage(immdata$data, "HomoSapiens.trbv")
# imm_gu = geneUsage(immdata$data, "hs.TRBV")
# imm_gu = geneUsage(immdata$data, "HomoSapiens.TRBV")
imm_gu

# Compute the distribution of the first two samples
imm_gu <- geneUsage(TCR_immdata$data[c(1, 2)], "hs.trbv", .norm = T)

vis(imm_gu)

imm_gu <- geneUsage(TCR_immdata$data, "hs.trbv", .norm = T)

vis(imm_gu, .by = "pCRstatus", .meta = TCR_immdata$meta)

# Grid
vis(imm_gu, .grid = T)

# Another practical approach to the visualisation of group distributions are box plots
vis(imm_gu, .by = "pCRstatus", .meta = TCR_immdata$meta, .plot = "box")


## Gene Usage Analysis ##
imm_gu <- geneUsage(TCR_immdata$data, "hs.trbv", .norm = T)

imm_gu_js <- geneUsageAnalysis(imm_gu, .method = "js", .verbose = F)
imm_gu_cor <- geneUsageAnalysis(imm_gu, .method = "cor", .verbose = F)

(p1 <- vis(imm_gu_js, .title = "Gene usage JS-divergence", .leg.title = "JS", .text.size = 1.5))
(p2 <- vis(imm_gu_cor, .title = "Gene usage correlation", .leg.title = "Cor", .text.size = 1.5))


imm_gu_js[is.na(imm_gu_js)] <- 0

vis(geneUsageAnalysis(imm_gu, "cosine+hclust", .verbose = F))

imm_cl_pca <- geneUsageAnalysis(imm_gu, "js+pca+kmeans", .verbose = F)
imm_cl_mds <- geneUsageAnalysis(imm_gu, "js+mds+kmeans", .verbose = F)
imm_cl_tsne <- geneUsageAnalysis(imm_gu, "js+tsne+kmeans", .perp = .01, .verbose = F)

p1 <- vis(imm_cl_pca, .plot = "clust")
p2 <- vis(imm_cl_mds, .plot = "clust")
p3 <- vis(imm_cl_tsne, .plot = "clust")
p1 + p2 + p3



imm_cl_pca2 <- geneUsageAnalysis(imm_gu, "js+pca+kmeans", .k = 3, .verbose = F)
vis(imm_cl_pca2)

# Spectratyping

# Spectratype is a useful way to represent distributions of genes per sequence length. 
# Parameter .quant controls the quantity that used to compute proportions of genes - either by clonotype (id) or by number of clones per clonotype (count). 
# Parameter .col controls which column to choose, e.g., “nt” for lengths of CDR3 nucleotide sequences only (without grouping by gene segments), “aa+v” for lengths of CDR3 amino acid sequences (grouped by V gene segments).

(p1 <- vis(spectratype(TCR_immdata$data[[1]], .quant = "id", .col = "nt")))
(p2 <- vis(spectratype(TCR_immdata$data[[1]], .quant = "count", .col = "aa+v")))
```


**Diversity Estimation**
```{r}
# Diversity Estimation

# Compute statistics and visualise them
# Chao1 diversity measure
div_chao <- repDiversity(TCR_immdata$data, "chao1")

# Hill numbers
div_hill <- repDiversity(TCR_immdata$data, "hill")

# D50
div_d50 <- repDiversity(TCR_immdata$data, "d50")

# Ecological diversity measure
div_div <- repDiversity(TCR_immdata$data, "div")

(p1 <- vis(div_chao, .sort = T))
(p2 <- vis(div_chao, .by = c("pCRstatus"), .meta = TCR_immdata$meta))

(p3 <- vis(div_hill, .by = c("pCRstatus"), .meta = TCR_immdata$meta))

(p4 <- vis(div_d50))

(p5 <- vis(div_d50, .by = "pCRstatus", .meta = TCR_immdata$meta))

(p6 <- vis(div_div, .sort = T))

imm_raref <- repDiversity(TCR_immdata$data, "raref", .verbose = F)

(p1 <- vis(imm_raref))

(p2 <- vis(imm_raref, .by = "pCRstatus", .meta = TCR_immdata$meta))

repDiversity(TCR_immdata$data, "raref", .verbose = F) %>% vis(.log = TRUE)
```
